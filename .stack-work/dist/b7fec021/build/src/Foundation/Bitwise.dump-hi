
==================== FINAL INTERFACE ====================
2016-12-17 14:56:52.7567232 UTC

interface Sophy-0.1.0.0-KzkJ0b2opaf7oLnrOdwoet:Bitwise 8001
  interface hash: 58aa86273c213db25f4710398dd81c08
  ABI hash: dac3e64a54b8be9d7c8e1f130b8e73fa
  export-list hash: 9b4cf91b2dee21d2fcd203a2334d40a1
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 6861b54f22d643b04766ce28c16cccec
  sig of: Nothing
  used TH splices: False
  where
exports:
  Bitwise.collapse
  Bitwise.deltaSwap
  Bitwise.disjoint
  Bitwise.joint
  Bitwise.ls1b
  Bitwise.oneBit
  Bitwise.populated
  Bitwise.without
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Bits c954f6297e2203ba924b7d4bb91aa2cf
import  -/  base-4.9.0.0:Data.List d711f98b49ef5d33e5b3d404631ed073
import  -/  base-4.9.0.0:Data.OldList 3c899c6d8e6204063769214449ac0954
import  -/  base-4.9.0.0:GHC.Num f0aed3315b3ed1b330b71fc4148a5581
import  -/  base-4.9.0.0:Prelude 2d9cd8b0ec3d728f62b734df888d2e34
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
fixities infix 4 disjoint, infix 4 joint, infixl 7 without
de3e967839203df2f66a2f61c240f787
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Bitwise.$trModule2
                   Bitwise.$trModule1) -}
7967350ac1a6bde1b3e771c43acb8eb2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Bitwise"#) -}
144129507618ac7d1887e44c98edca72
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Sophy-0.1.0.0-KzkJ0b2opaf7oLnrOdwoet"#) -}
466736918cf20f0ebb026d98a12c7059
  collapse :: (Data.Bits.Bits a, GHC.Num.Num a) => a -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SC(C(S))LLLLLLLLLLLLLLLLLLLLL),U(1*U,C(C1(U)),A,C(C1(U)),A,A,A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(U),A,A,A)><S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   ($dBits :: Data.Bits.Bits a)
                   ($dNum :: GHC.Num.Num a)
                   (eta :: a) ->
                 let {
                   $dEq :: GHC.Classes.Eq a = Data.Bits.$p1Bits @ a $dBits
                 } in
                 GHC.Base.build
                   @ a
                   (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    letrec {
                      go :: a -> b1 {- Arity: 1 -}
                      = \ (b2 :: a) ->
                        case b2 of xs { DEFAULT ->
                        case Data.Bits..&.
                               @ a
                               $dBits
                               xs
                               (GHC.Num.negate @ a $dNum xs) of x { DEFAULT ->
                        case GHC.Classes.==
                               @ a
                               $dEq
                               xs
                               (Data.Bits.zeroBits @ a $dBits) of wild {
                          GHC.Types.False -> c x (go (Data.Bits.xor @ a $dBits xs x))
                          GHC.Types.True -> n } } }
                    } in
                    go eta)) -}
e92050604ec97909731b612792bc8d2c
  deltaSwap :: Data.Bits.Bits a => a -> GHC.Types.Int -> a -> a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))LC(C(S))LLLLLLLLLLLLLLLLLLL),U(A,C(C1(U)),A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,1*C1(C1(U)),A,A,A,A)><S,1*U><S,1*U(U)><S,1*U>,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (4, False, False)
                (\ @ a
                   ($dBits :: Data.Bits.Bits a)
                   (mask :: a)
                   (distance :: GHC.Types.Int)
                   (source :: a) ->
                 case mask of mask1 { DEFAULT ->
                 case distance of distance1 { GHC.Types.I# ipv ->
                 case source of source1 { DEFAULT ->
                 case Data.Bits..&.
                        @ a
                        $dBits
                        (Data.Bits.shiftL @ a $dBits mask1 distance1)
                        source1 of toMask { DEFAULT ->
                 case Data.Bits..&.
                        @ a
                        $dBits
                        mask1
                        source1 of fromMask { DEFAULT ->
                 case Data.Bits.xor
                        @ a
                        $dBits
                        (Data.Bits.shiftL @ a $dBits fromMask distance1)
                        toMask of xored { DEFAULT ->
                 Data.Bits.xor
                   @ a
                   $dBits
                   (Data.Bits.xor @ a $dBits source1 xored)
                   (Data.Bits.shiftR @ a $dBits xored distance1) } } } } } }) -}
d4b6a06978fcf65d85a494a1597099df
  disjoint :: Data.Bits.Bits a => a -> a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(1*C1(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a ($dBits :: Data.Bits.Bits a) (eta :: a) (eta1 :: a) ->
                 case eta of a1 { DEFAULT ->
                 case eta1 of b { DEFAULT ->
                 GHC.Classes.==
                   @ a
                   (Data.Bits.$p1Bits @ a $dBits)
                   (Data.Bits..&. @ a $dBits a1 b)
                   (Data.Bits.zeroBits @ a $dBits) } }) -}
d98fb2644b317d27b91085307d2a9706
  joint :: Data.Bits.Bits a => a -> a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LC(C(S)))LLLLLLLLLLLLLLLLLLLLLL),U(1*U(A,1*C1(C1(U))),1*C1(C1(U)),A,A,A,A,A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a ($dBits :: Data.Bits.Bits a) (eta :: a) (eta1 :: a) ->
                 case eta of a1 { DEFAULT ->
                 case eta1 of b { DEFAULT ->
                 GHC.Classes./=
                   @ a
                   (Data.Bits.$p1Bits @ a $dBits)
                   (Data.Bits..&. @ a $dBits a1 b)
                   (Data.Bits.zeroBits @ a $dBits) } }) -}
ac3d5825744bf54fdf31bb0155e2b05e
  ls1b :: (Data.Bits.Bits a, GHC.Num.Num a) => a -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLLLLLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,A,1*C1(U),A,A,A)><S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dBits :: Data.Bits.Bits a)
                   ($dNum :: GHC.Num.Num a)
                   (x :: a) ->
                 case x of x1 { DEFAULT ->
                 Data.Bits..&. @ a $dBits x1 (GHC.Num.negate @ a $dNum x1) }) -}
82c90513f774ca67d7fb810d6b2f96bf
  oneBit :: (Data.Bits.Bits a, GHC.Num.Num a) => a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,1*C1(C1(U)),A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))><S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dBits :: Data.Bits.Bits a)
                   ($dNum :: GHC.Num.Num a)
                   (eta :: a) ->
                 let {
                   $dEq :: GHC.Classes.Eq a = Data.Bits.$p1Bits @ a $dBits
                 } in
                 case eta of x { DEFAULT ->
                 GHC.Classes.&&
                   (GHC.Classes./= @ a $dEq x (Data.Bits.zeroBits @ a $dBits))
                   (GHC.Classes.==
                      @ a
                      $dEq
                      (Data.Bits..&.
                         @ a
                         $dBits
                         x
                         (GHC.Num.- @ a $dNum x (GHC.Num.fromInteger @ a $dNum 1)))
                      (Data.Bits.zeroBits @ a $dBits)) }) -}
75e80f725612686eb7f81f1ce5359273
  populated :: Data.Bits.Bits a => a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S)))LLLLLLLLLLLLLLLLLLLLLL),U(1*U(A,1*C1(C1(U))),A,A,A,A,A,A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (1, False, False)
                (\ @ a ($dBits :: Data.Bits.Bits a) (eta :: a) ->
                 GHC.Classes./=
                   @ a
                   (Data.Bits.$p1Bits @ a $dBits)
                   eta
                   (Data.Bits.zeroBits @ a $dBits)) -}
67ce45f5ed5d75206d3b7d6f09efeff7
  without :: Data.Bits.Bits a => a -> a -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLLLLLLLLLLLLLLLLL),U(A,1*C1(C1(U)),A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a ($dBits :: Data.Bits.Bits a) (a1 :: a) (b :: a) ->
                 case a1 of a2 { DEFAULT ->
                 case b of b1 { DEFAULT ->
                 Data.Bits..&.
                   @ a
                   $dBits
                   a2
                   (Data.Bits.complement @ a $dBits b1) } }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

